function writexml(xmlstruct, filename)
%WRITEXML XML writer, using libxml2.
%
% writexml(xmlstruct, xmlfilename)
%
% Routine for writing an XML-based MATLAB struct (as returned by
% readxml()) to an XML file.
%
% Any struct that fails the validity test used by writexml()
% will not be written.  All structs generated by readxml() are
% expected to be valid.

% This function is implemented as a MEX file.

CVSId = '$Id: writexml.m,v 1.7 2005/02/22 20:18:25 michelich Exp $';
% CVSRevision = '$Revision: 1.7 $';
% CVSDate = '$Date: 2005/02/22 20:18:25 $';
% CVSRCSFile = '$RCSfile: writexml.m,v $';

[majorVer, minorVer] = strtok(strtok(version),'.');
majorVer = str2double(majorVer);
minorVer = str2double(strtok(minorVer,'.'));
if majorVer < 6 | (majorVer == 6 & minorVer < 5)
  errmsg = 'For Matlab versions earlier than 6.5 (R13), you need to compile the MEX file writexml.c (requires libxml2, and is much faster)';
  error(errmsg);
else
  warning('writexml:compile', sprintf('You are using the non-compiled version of writexml which is very slow\nand does not necessarily work correctly.\nIf you have libxml2 available, please consider compiling writexml.c.'));
end
clear majorVer minorVer

[fid, msg] = fopen(filename, 'w');
if fid == -1, error(msg); end
fprintf(fid, '<?xml version="1.0"?>\n');
fprintf(fid, '%s', sprintf('<!--AUTOGEN:\n File automatically generated by MATLAB function writexml.m\n ('));
fprintf(fid, '%s', CVSId);
tvec = fix(clock);
fprintf(fid, ')\n on %d/%02d/%02d %02d:%02d:%02d\n-->', tvec(:));
contents = outputXmlNodeContents(xmlstruct, [], struct([]), 0);
fwrite(fid, contents, 'uchar');
fclose(fid);
return

function [defaultns, nsdecls]=getNewNSDecls(elem, indefaultns, innsdecls)
defaultns = indefaultns;
nsdecls = innsdecls;
if isfield(elem, 'NSDEFS')
  prefixes = fieldnames(elem.NSDEFS);
  numprefixes = length(prefixes);
  for prefixnum = 1:numprefixes
    prefix = prefixes{prefixnum};
    uri = getfield(elem.NSDEFS, prefix);
    if strcmp(prefix, 'DEFAULT')
      defaultns = uri;
    else
      if isempty(nsdecls)
        nsdecls = struct(prefix, {uri});
      else
        nsdecls = setfield(nsdecls, prefix, uri);
      end
    end
  end
end
return

function retstr=outputXmlNodeAttributes(elem, defaultns, nsdecls, indentlevel)
retstr = '';
if isfield(elem, 'NSDEFS')
  if isfield(elem.NSDEFS, 'DEFAULT')
    % do default namespace first
    uri = elem.NSDEFS.DEFAULT;
    retstr = [retstr sprintf('xmlns="%s" ', escapestr(uri))];
  end
  prefixes = fieldnames(elem.NSDEFS);
  numprefixes = length(prefixes);
  for prefixnum = 1:numprefixes
    prefix = prefixes{prefixnum};
    uri = getfield(elem.NSDEFS, prefix);
    if ~strcmp(prefix, 'DEFAULT')
      retstr = [retstr sprintf('xmlns:%s="%s" ', prefix, escapestr(uri))];
    end
  end
end
if isfield(elem, 'ATTRS')
  attrnames = fieldnames(elem.ATTRS);
  numnames = length(attrnames);
  for attrnum = 1:numnames
    attrname = attrnames{attrnum};
    attrvalue = getfield(elem.ATTRS, attrname);
    attrvalue = attrvalue.VALUE;
    retstr = [retstr sprintf('%s="%s"', attrname, escapestr(attrvalue))];
  end
end
return

function retstr=outputXmlNodeContents(node, defaultns, nsdecls, indentlevel)
% do those nodes with explicit rank first
retstr = '';
ordered = struct('type', {}, 'rank', {}, 'name', {}, 'node', {});
fields = fieldnames(node);
numfields = length(fields);
for fieldnum = 1:numfields
  fieldname = fields{fieldnum};
%  fieldvalue = getfield(node, fieldname);
  if strcmp(fieldname, 'NSDEFS')
  elseif indentlevel == 0 & strcmp(fieldname, 'BASE')
  elseif strcmp(fieldname, 'NAMESPACE')
  elseif strcmp(fieldname, 'ATTRS')
  elseif strcmp(fieldname, 'VALUECHILDRANK')
  elseif strcmp(fieldname, 'CHILDRANK')
  elseif strcmp(fieldname, 'PINSTS')
    num = length(node.PINSTS);
    for ind = 1:num
      pinst = node.PINSTS{ind};
      rank = Inf;
      if length(pinst) == 3
        rank = pinst{3};
      end
      ordered(end+1) = struct('type', {'PINST'}, 'rank', rank, 'name', {[]}, 'node', {pinst});
    end
  elseif strcmp(fieldname, 'COMMENTS')
    num = length(node.COMMENTS);
    for ind = 1:num
      comment = node.COMMENTS(ind);
      rank = Inf;
      if isfield(comment, 'CHILDRANK') & ~isempty(comment.CHILDRANK)
        rank = comment.CHILDRANK;
      end
      ordered(end+1) = struct('type', {'COMMENT'}, 'rank', rank, 'name', {[]}, 'node', {comment.VALUE});
    end
  elseif strcmp(fieldname, 'VALUE')
    rank = Inf;
    if isfield(node, 'VALUECHILDRANK') & ~isempty(node.VALUECHILDRANK)
      rank = node.VALUECHILDRANK;
    end
    ordered(end+1) = struct('type', {'TEXT'}, 'rank', rank, 'name', {[]}, 'node', {escapestr(node.VALUE)});
  else
    % regular child node
    children = getfield(node, fieldname);
    num = length(children);
    for ind = 1:num
      child = children{ind};
      rank = Inf;
      if isfield(child, 'CHILDRANK') & ~isempty(child.CHILDRANK)
        rank = child.CHILDRANK;
      end
      ordered(end+1) = struct('type', {'ELEMENT'}, 'rank', rank, 'name', {fieldname}, 'node', {child});
    end
  end
end
% sort chosen nodes by rank
[s, sinds] = sort([ordered.rank]);
ordered = ordered(sinds);
% output these nodes in order
foundnontext = 0;
for entry=ordered
  oetype = entry.type;
  oerank = entry.rank;
  oename = entry.name;
  oenode = entry.node;
  indent = repmat(' ', 1, indentlevel);
  if ~strcmp(oetype, 'TEXT'), foundnontext = 1; end
  switch oetype
   case 'PINST'
    retstr = [retstr sprintf('\n%s<?%s %s?>', indent, oenode{1}, oenode{2})];
   case 'TEXT'
    if foundnontext
      retstr = [retstr sprintf('\n%s%s', indent, oenode)];
    else
      retstr = [retstr sprintf('%s', oenode)];
    end
   case 'COMMENT'
    retstr = [retstr sprintf('\n%s<!--%s-->', indent, oenode)];
   case 'ELEMENT'
    [newdefaultns, newnsdecls] = getNewNSDecls(oenode, defaultns, nsdecls);
    ns = [];
    nsprefix = [];
    if isfield(oenode, 'NAMESPACE'), ns = oenode.NAMESPACE; end
    if ~isempty(ns) & ~strcmp(ns, newdefaultns)
      prefixes = fieldnames(newnsdecls);
      numprefixes = length(prefixes);
      for prefixnum = 1:numprefixes
        prefix = prefixes{prefixnum};
        if strcmp(ns, getfield(newnsdecls, prefix))
          nsprefix = prefix;
        end
      end
    end
    attrs = outputXmlNodeAttributes(oenode, newdefaultns, newnsdecls, indentlevel + 2);
    contents = outputXmlNodeContents(oenode, newdefaultns, newnsdecls, indentlevel + 2);
    tagname = oename;
    if ~isempty(nsprefix)
      tagname = [nsprefix ':' oename];
    end
    attrsep = '';
    if ~isempty(attrs), attrsep = ' '; end
    if isempty(contents)
      retstr = [retstr ...
                sprintf('\n%s<%s', indent, tagname) ...
                attrsep attrs ...
                sprintf('/>')];
    else
      retstr = [retstr ...
                sprintf('\n%s<%s', indent, tagname) ...
                attrsep attrs ...
                sprintf('>') ...
                contents ...
                sprintf('</%s>', tagname)];
    end
  end
end
if indentlevel ~= 0
  indent = repmat(' ', [1 indentlevel - 2]);
  if foundnontext
    retstr = [retstr sprintf('\n%s', indent)];
  end
else
  retstr = [retstr sprintf('\n')];
end
return

function newstr=escapestr(oldstr)
if isnumeric(oldstr)
  nums = oldstr;
  oldstr = '';
  for ind=1:length(nums)
    numsep = '';
    if ind < length(nums), numsep = ' '; end
    oldstr = [oldstr sprintf(['%.15g' numsep], nums(ind))];
  end
end
newstr = oldstr;
return

% $Log: writexml.m,v $
% Revision 1.7  2005/02/22 20:18:25  michelich
% Use more robust version parsing code.
%
% Revision 1.6  2005/02/03 16:58:36  michelich
% Changes based on M-lint:
% Make unused CVS variables comments for increased efficiency.
% Remove unnecessary semicolon after function declarations.
% Remove unnecessary commas after try, catch, and else statements.
%
% Revision 1.5  2004/07/20 13:32:12  gadde
% Get rid of extraneous command.
%
% Revision 1.4  2004/07/19 19:21:50  gadde
% Fixed bug where elements without explicit CHILDRANK were not written at all.
%
% Revision 1.3  2004/04/16 17:57:25  gadde
% Be more emphatic in warning.
%
% Revision 1.2  2004/04/16 17:26:42  gadde
% SLOW version of writexml intended for use when you don't have libxml2.
%
